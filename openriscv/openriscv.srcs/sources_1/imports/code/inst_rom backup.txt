// ============================================================
// 指令覆盖测试程序（严格按你当前代码真实支持的 50 条指令集合）
// - 包含：RV32I 子集 + RV32M + Zbb 子集(5条：min/minu/max/maxu/andn)
// - 不包含：fence/fence.i/ecall/ebreak/csrrw（你已删除且代码未实现）
// 注意：inst_rom.v 会对 ROM 读出的 32-bit 数据做字节翻转，
//       所以本文件每行是“按字节倒序”的 8 位十六进制串。
// ============================================================

e7002000    // 0x00: jalr  x1, x0, 2  | 跳转: PC=0x04(=0x00+4)；写回: x1=0x00000004
37010100    // 0x04: lui   x2, 0x10   | 写回: x2=0x00010000
97010000    // 0x08: auipc x3, 0      | 写回: x3=0x00000008 (当前PC)

1302703e    // 0x0C: addi  x4, x0, 999 | 写回: x4=0x000003E7 (999)
93625205    // 0x10: ori   x5, x4, 0x55 | 写回: x5=0x000003F7 (1015)
13c3f200    // 0x14: xori  x6, x5, 0x0f | 写回: x6=0x000003F8 (1016)
9373f300    // 0x18: andi  x7, x6, 0x0f | 写回: x7=0x00000008 (8)
13942300    // 0x1C: slli  x8, x7, 2    | 写回: x8=0x00000020 (32)
93541400    // 0x20: srli  x9, x8, 1    | 写回: x9=0x00000010 (16)
13551440    // 0x24: srai  x10, x8, 1   | 写回: x10=0x00000010 (16)
93258200    // 0x28: slti  x11, x4, 8   | 写回: x11=0x00000000
13368200    // 0x2C: sltiu x12, x4, 8   | 写回: x12=0x00000000

b3065200    // 0x30: add   x13, x4, x5  | 写回: x13=0x000007DE (2014)
33874640    // 0x34: sub   x14, x13, x4 | 写回: x14=0x000003F7 (1015)
b3e76200    // 0x38: or    x15, x5, x6  | 写回: x15=0x000003FF (1023)
33c86200    // 0x3C: xor   x16, x5, x6  | 写回: x16=0x0000000F (15)
b3f86200    // 0x40: and   x17, x5, x6  | 写回: x17=0x000003F0 (1008)
33197200    // 0x44: sll   x18, x4, x7  | 写回: x18=0x0003E700 (255744)
b3597900    // 0x48: srl   x19, x18, x7 | 写回: x19=0x000003E7 (999)
335a7940    // 0x4C: sra   x20, x18, x7 | 写回: x20=0x000003E7 (999)
b3aa4200    // 0x50: slt   x21, x5, x4  | 写回: x21=0x00000000
33bb4200    // 0x54: sltu  x22, x5, x4  | 写回: x22=0x00000000

b30b5202    // 0x58: mul   x23, x4, x5  | 写回: x23=0x000F78E1 (1013985)
331c5202    // 0x5C: mulh  x24, x4, x5  | 写回: x24=0x00000000 (乘积高32位)
b32c5202    // 0x60: mulhsu x25, x4, x5 | 写回: x25=0x00000000 (乘积高32位)
333d5202    // 0x64: mulhu x26, x4, x5  | 写回: x26=0x00000000 (乘积高32位)
b3cd4202    // 0x68: div   x27, x5, x4  | 写回: x27=0x00000001 (1015/999)
33de4202    // 0x6C: divu  x28, x5, x4  | 写回: x28=0x00000001
b3ee4202    // 0x70: rem   x29, x5, x4  | 写回: x29=0x00000010 (余数16)
33ff4202    // 0x74: remu  x30, x5, x4  | 写回: x30=0x00000010

3343520a    // 0x78: min   x6,  x4, x5  | 写回: x6=0x000003E7 (999)
b353520a    // 0x7C: minu  x7,  x4, x5  | 写回: x7=0x000003E7 (999)
3364520a    // 0x80: max   x8,  x4, x5  | 写回: x8=0x000003F7 (1015)
b374520a    // 0x84: maxu  x9,  x4, x5  | 写回: x9=0x000003F7 (1015)
33755240    // 0x88: andn  x10, x4, x5  | 写回: x10=0x00000000 (x4 & ~x5)

// 访存段说明：为便于“快速验证”，这里全部用偏移0，避免字节/半字 lane 的实现差异。
23204000    // 0x8C: sw    x4, 0(x0)    | RAM[0]=0x000003E7
832f0000    // 0x90: lw    x31, 0(x0)   | 写回: x31=0x000003E7
23004000    // 0x94: sb    x4, 0(x0)    | RAM[0]=0x000000E7 (仅低8位)
83000000    // 0x98: lb    x1, 0(x0)    | 写回: x1=0xFFFFFFE7 (符号扩展, -25)
03410000    // 0x9C: lbu   x2, 0(x0)    | 写回: x2=0x000000E7 (231)
23105000    // 0xA0: sh    x5, 0(x0)    | RAM[0]=0x000003F7 (仅低16位)
83110000    // 0xA4: lh    x3, 0(x0)    | 写回: x3=0x000003F7 (符号扩展)
03530000    // 0xA8: lhu   x6, 0(x0)    | 写回: x6=0x000003F7 (零扩展)

// B 型：imm=+4 让跳转目标等于顺序下一条，保证覆盖顺序执行
63024200    // 0xAC: beq   x4, x4, +4   | 条件真；PC仍=下一条(imm=+4)；现象：ID会触发stall(本设计对B类统一暂停)
63125200    // 0xB0: bne   x4, x5, +4   | 条件真(999!=1015)；PC仍=下一条；现象同上
63425200    // 0xB4: blt   x4, x5, +4   | 条件真(999<1015,signed)；PC仍=下一条；现象同上
63d24200    // 0xB8: bge   x5, x4, +4   | 条件真；PC仍=下一条；现象同上
63625200    // 0xBC: bltu  x4, x5, +4   | 条件真(unsig)；PC仍=下一条；现象同上
63f24200    // 0xC0: bgeu  x5, x4, +4   | 条件真(unsig)；PC仍=下一条；现象同上

// JAL：imm=+4 同理保持顺序，但走 JAL 路径
ef014000    // 0xC4: jal   x3, +4       | 跳转: PC=0xC8；写回: x3=0x000000C8（建议用 reg3_o 当“结束标志”）