# RISC-V 五级流水线 CPU 原理教程

本教程将帮助您从零理解这个 CPU 的工作原理，并学会看懂仿真波形。

---

## 第一部分：CPU 基础概念

### 什么是 CPU？

CPU（中央处理器）的核心任务是**执行指令**。每条指令告诉 CPU 做一件事，比如：
- 把两个数相加
- 从内存读取数据
- 跳转到另一条指令

### 指令执行的五个步骤

执行一条指令需要以下步骤（无论什么 CPU 都类似）：

```
┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐
│  取指   │ → │  译码   │ → │  执行   │ → │  访存   │ → │  写回   │
│  (IF)   │   │  (ID)   │   │  (EX)   │   │  (MEM)  │   │  (WB)   │
└─────────┘   └─────────┘   └─────────┘   └─────────┘   └─────────┘
```

| 阶段 | 英文 | 做什么？ | 对应模块 |
|------|------|----------|----------|
| **取指** | IF (Instruction Fetch) | 从内存读取指令 | `pc_reg.v`, `inst_rom.v` |
| **译码** | ID (Instruction Decode) | 分析指令含义，读取寄存器 | `id.v` |
| **执行** | EX (Execute) | 执行运算（加减乘除等） | `ex.v` |
| **访存** | MEM (Memory Access) | 读写数据内存 | `mem.v`, `data_ram.v` |
| **写回** | WB (Write Back) | 把结果写回寄存器 | `regfile.v` |

---

## 第二部分：什么是流水线？

### 没有流水线的 CPU

假设每个阶段需要 1 个时钟周期，执行 3 条指令需要：

```
指令1: IF → ID → EX → MEM → WB (5个周期)
指令2:                        IF → ID → EX → MEM → WB (又5个周期)
指令3:                                               IF → ... (再5个周期)
总共: 15 个周期
```

### 有流水线的 CPU

流水线让不同阶段同时工作，就像工厂流水线：

```
时钟:   1    2    3    4    5    6    7
指令1: IF → ID → EX → MEM → WB
指令2:      IF → ID → EX  → MEM → WB
指令3:           IF → ID  → EX  → MEM → WB
```

执行 3 条指令只需要 **7 个周期**，效率大幅提升！

### 流水线寄存器

为了让每个阶段独立工作，阶段之间需要**流水线寄存器**来保存中间结果：

```
┌──────┐   ┌───────┐   ┌──────┐   ┌───────┐   ┌──────┐   ┌───────┐   ┌──────┐   ┌───────┐   ┌──────┐
│PC_REG│ → │ IF/ID │ → │  ID  │ → │ ID/EX │ → │  EX  │ → │EX/MEM │ → │ MEM  │ → │MEM/WB │ → │  WB  │
└──────┘   └───────┘   └──────┘   └───────┘   └──────┘   └───────┘   └──────┘   └───────┘   └──────┘
              ↑            ↑          ↑           ↑          ↑           ↑          ↑
          流水线寄存器  流水线寄存器  流水线寄存器  流水线寄存器  流水线寄存器  流水线寄存器
```

在代码中对应：
- `if_id.v` - IF/ID 流水线寄存器
- `id_ex.v` - ID/EX 流水线寄存器
- `ex_mem.v` - EX/MEM 流水线寄存器
- `mem_wb.v` - MEM/WB 流水线寄存器

---

## 第三部分：代码结构对照

### 项目文件一览

```
code/
├── define.v          ← 宏定义（常量、位宽等）
├── pc_reg.v          ← 程序计数器 (PC)
├── inst_rom.v        ← 指令存储器 (ROM)
├── if_id.v           ← IF/ID 流水线寄存器
├── id.v              ← 译码模块
├── regfile.v         ← 寄存器堆 (x0-x31)
├── id_ex.v           ← ID/EX 流水线寄存器
├── ex.v              ← 执行模块
├── ex_mem.v          ← EX/MEM 流水线寄存器
├── mem.v             ← 访存模块
├── data_ram.v        ← 数据存储器 (RAM)
├── mem_wb.v          ← MEM/WB 流水线寄存器
├── ctrl.v            ← 控制模块（暂停流水线等）
└── openriscv.v       ← 顶层模块（连接所有子模块）
```

### 顶层模块连接图

```
                    ┌─────────────────────────────────────────────────────────┐
                    │                      openriscv.v                        │
                    │                                                         │
 inst_rom ─────────►│  pc_reg → if_id → id → id_ex → ex → ex_mem → mem → mem_wb → regfile
                    │     ↑                  ↑                                    │
                    │     │                  │                                    │
                    │     └── ctrl ◄─────────┴── 暂停请求                          │
                    │                                                         │
                    └─────────────────────────────────────────────────────────┘
```

---

## 第四部分：理解仿真波形

本工程自带 Vivado 仿真工程与波形配置文件，你可以直接在 Vivado 的行为级仿真里观察信号变化（例如打开工程目录下的 `openriscv_min_sopc_tb_behav.wcfg`）。

### 信号与模块对应

| 波形信号 | 来源模块 | 含义 |
|----------|----------|------|
| `CLOCK_50` | 顶层输入 | 系统时钟，每 20ns 翻转一次 |
| `rst` | 顶层输入 | 复位信号 |
| `pc_i[31:0]` | `pc_reg.v` | 程序计数器：当前正在取的指令地址 |
| `inst_i[31:0]` | `inst_rom.v` | 从 ROM 读出的指令 |
| `reg1_o`, `reg2_o` | `id.v` 输出 | 译码阶段读出的两个源寄存器值 |
| `branch_flag_o` | `id.v` 输出 | 是否需要分支跳转 |
| `branch_addr_o` | `id.v` 输出 | 分支目标地址 |
| `wr_addr[4:0]` | `regfile.v` | 写回阶段的目标寄存器编号 |
| `wr_data[31:0]` | `regfile.v` | 写回阶段的数据 |

### 执行过程追踪

当前工程的测试程序不是斐波那契，而是“**指令覆盖测试程序**”，位于：

- `openriscv/openriscv.srcs/sources_1/imports/code/inst_rom.txt`

它会覆盖：RV32I(37条子集) + RV32M(8条) + Zbb子集(5条：min/minu/max/maxu/andn)。

建议的验证方式：

- 观察 `regfile` 写回端口（如 `wr_addr`/`wr_data`）是否与 `inst_rom.txt` 中每条指令注释的“写回预期值”一致。
- 观察访存相关信号（`ram_addr`/`ram_we`/`ram_data`）是否符合 lw/lb/lbu/lh/lhu 与 sw/sb/sh 的行为。

注意：`inst_rom.v` 会对 ROM 中读出的 32-bit 指令做字节翻转（小端字节序转换），因此 `inst_rom.txt` 里每一行的 8 位十六进制串是“按字节倒序”的表示。

---

## 第五部分：一条指令的完整旅程

以 `addi x1, x0, 1` (x1 = x0 + 1) 为例：

### 周期 1：取指 (IF)
- `pc_reg` 输出 PC = 0x00000000
- `inst_rom` 根据地址返回一条 32 位指令（ROM 读取时会做字节翻转）

### 周期 2：译码 (ID)
- `if_id` 将指令传给 `id` 模块
- `id` 解析指令：
  - opcode = 0010011 (I型指令)
  - rd = 00001 (x1)
  - rs1 = 00000 (x0)
  - imm = 1
- 从 `regfile` 读取 x0 的值 = 0

### 周期 3：执行 (EX)
- `id_ex` 将数据传给 `ex` 模块
- `ex` 计算：0 + 1 = 1

### 周期 4：访存 (MEM)
- 这条指令不需要访问内存，直接传递结果

### 周期 5：写回 (WB)
- `mem_wb` 将结果传给 `regfile`
- `regfile` 将 1 写入 x1 寄存器

---

## 总结

1. **CPU = 取指 + 译码 + 执行 + 访存 + 写回**
2. **流水线** 让多条指令同时在不同阶段执行，提高效率
3. **流水线寄存器** 隔离各阶段，保存中间数据
4. **仿真波形** 是 CPU 内部信号随时间变化的快照

补充：当前实现额外支持 RV32M 与 Zbb 子集运算（实现主要集中在 `ex.v`）。

如果您想深入学习，建议：
1. 阅读 `id.v` 了解指令如何被解析
2. 阅读 `ex.v` 了解 ALU 如何运算
3. 对照 RISC-V 指令手册理解指令编码
